---
title: "Deploying MCP Servers on AWS ECS: A Production Infrastructure Guide"
date: "2025-10-25"
author: "AWS Developer"
excerpt: "Learn how to deploy and scale Model Context Protocol (MCP) servers on AWS ECS with best practices for production workloads and container orchestration."
category: "Infrastructure"
tags: ["AWS ECS", "MCP Servers", "Container Orchestration", "Claude Code", "Infrastructure as Code"]
published: true
---

# Deploying MCP Servers on AWS ECS: A Production Infrastructure Guide

## Introduction

Model Context Protocol (MCP) servers extend the capabilities of AI tools like Claude Code by providing specialized integrations with databases, APIs, and external services. But running these servers reliably at scale requires robust infrastructure. How do you ensure your MCP servers are highly available, automatically scaled, and cost-efficient?

AWS Elastic Container Service (ECS) provides the perfect platform for deploying MCP servers. With ECS, you get managed container orchestration, seamless AWS service integration, and the flexibility to run on either EC2 or Fargate. In this guide, you'll learn how to containerize MCP servers, deploy them to ECS, and implement production-ready patterns for monitoring and scaling.

**Who this guide is for:** DevOps engineers, infrastructure architects, and developers building production Claude Code environments with custom MCP server integrations.

## Prerequisites

Before deploying MCP servers to ECS, ensure you have:

**AWS Access and Permissions:**
- An active AWS account with administrative access
- IAM permissions for `ecs:*`, `ecr:*`, `ec2:*`, and `iam:*` actions
- Access to create Application Load Balancers (ALB) and security groups

**Required Tools:**
- Docker Desktop or Docker Engine 20.x+
- AWS CLI v2.x configured with your credentials
- Node.js 18+ or Python 3.9+ (depending on your MCP server)
- Optional: Terraform or AWS CDK for Infrastructure as Code

**Prior Knowledge:**
- Familiarity with Docker and containerization concepts
- Basic understanding of AWS networking (VPC, subnets, security groups)
- Experience with MCP server development and configuration
- General knowledge of container orchestration

## Step-by-Step Guide

### 1. Understanding MCP Server Architecture on ECS

MCP servers are lightweight applications that expose tools and resources to AI assistants. When deployed on ECS, the architecture typically includes:

**Key Components:**
- **ECS Cluster:** Logical grouping of tasks and services
- **Task Definition:** Blueprint defining your containerized MCP server
- **ECS Service:** Ensures desired number of tasks are running
- **Application Load Balancer:** Routes traffic to healthy MCP server instances
- **CloudWatch Logs:** Centralized logging for monitoring and debugging

**Deployment Patterns:**
- **Fargate Launch Type:** Serverless compute for MCP servers (recommended for simplicity)
- **EC2 Launch Type:** Self-managed instances for cost optimization at scale

### 2. Containerizing Your MCP Server

Let's start by creating a production-ready Docker image for an MCP server. Here's an example `Dockerfile` for a Node.js-based MCP server:

```dockerfile
# Use official Node.js LTS image
FROM node:18-alpine AS builder

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production

# Copy application code
COPY . .

# Build TypeScript if applicable
RUN npm run build || true

# Production stage
FROM node:18-alpine

WORKDIR /app

# Copy dependencies and built code from builder
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./

# Create non-root user for security
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

USER nodejs

# Expose MCP server port
EXPOSE 3000

# Health check for ECS
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (r) => process.exit(r.statusCode === 200 ? 0 : 1))"

# Start the MCP server
CMD ["node", "dist/index.js"]
```

Build and test the container locally:

```bash
# Build the Docker image
docker build -t mcp-server:latest .

# Test locally
docker run -p 3000:3000 -e MCP_CONFIG='{"key":"value"}' mcp-server:latest

# Verify health endpoint
curl http://localhost:3000/health
```

### 3. Pushing to Amazon Elastic Container Registry (ECR)

Create an ECR repository and push your image:

```bash
# Create ECR repository
aws ecr create-repository \
  --repository-name mcp-servers/my-mcp-server \
  --region us-east-1

# Authenticate Docker to ECR
aws ecr get-login-password --region us-east-1 | \
  docker login --username AWS --password-stdin \
  123456789012.dkr.ecr.us-east-1.amazonaws.com

# Tag your image
docker tag mcp-server:latest \
  123456789012.dkr.ecr.us-east-1.amazonaws.com/mcp-servers/my-mcp-server:latest

# Push to ECR
docker push 123456789012.dkr.ecr.us-east-1.amazonaws.com/mcp-servers/my-mcp-server:latest
```

**Pro tip:** Use image tags with semantic versioning (e.g., `v1.2.3`) instead of `latest` for production deployments to ensure reproducibility.

### 4. Creating an ECS Task Definition

Define your containerized MCP server configuration:

```json
{
  "family": "mcp-server-task",
  "networkMode": "awsvpc",
  "requiresCompatibilities": ["FARGATE"],
  "cpu": "256",
  "memory": "512",
  "executionRoleArn": "arn:aws:iam::123456789012:role/ecsTaskExecutionRole",
  "taskRoleArn": "arn:aws:iam::123456789012:role/mcpServerTaskRole",
  "containerDefinitions": [
    {
      "name": "mcp-server",
      "image": "123456789012.dkr.ecr.us-east-1.amazonaws.com/mcp-servers/my-mcp-server:latest",
      "portMappings": [
        {
          "containerPort": 3000,
          "protocol": "tcp"
        }
      ],
      "environment": [
        {
          "name": "NODE_ENV",
          "value": "production"
        },
        {
          "name": "MCP_PORT",
          "value": "3000"
        }
      ],
      "secrets": [
        {
          "name": "API_KEY",
          "valueFrom": "arn:aws:secretsmanager:us-east-1:123456789012:secret:mcp-api-key"
        }
      ],
      "logConfiguration": {
        "logDriver": "awslogs",
        "options": {
          "awslogs-group": "/ecs/mcp-server",
          "awslogs-region": "us-east-1",
          "awslogs-stream-prefix": "ecs"
        }
      },
      "healthCheck": {
        "command": ["CMD-SHELL", "curl -f http://localhost:3000/health || exit 1"],
        "interval": 30,
        "timeout": 5,
        "retries": 3,
        "startPeriod": 10
      }
    }
  ]
}
```

Register the task definition:

```bash
aws ecs register-task-definition \
  --cli-input-json file://task-definition.json
```

### 5. Creating an ECS Service with Load Balancer

Deploy your MCP server with automatic scaling and load balancing:

```bash
# Create ECS cluster
aws ecs create-cluster --cluster-name mcp-cluster

# Create ECS service
aws ecs create-service \
  --cluster mcp-cluster \
  --service-name mcp-server-service \
  --task-definition mcp-server-task:1 \
  --desired-count 2 \
  --launch-type FARGATE \
  --network-configuration "awsvpcConfiguration={
    subnets=[subnet-12345,subnet-67890],
    securityGroups=[sg-0abcd1234],
    assignPublicIp=ENABLED
  }" \
  --load-balancers "targetGroupArn=arn:aws:elasticloadbalancing:us-east-1:123456789012:targetgroup/mcp-tg/abc123,containerName=mcp-server,containerPort=3000" \
  --health-check-grace-period-seconds 60
```

### 6. Configuring Auto Scaling

Enable automatic scaling based on CPU and memory utilization:

```bash
# Register scalable target
aws application-autoscaling register-scalable-target \
  --service-namespace ecs \
  --resource-id service/mcp-cluster/mcp-server-service \
  --scalable-dimension ecs:service:DesiredCount \
  --min-capacity 2 \
  --max-capacity 10

# Create scaling policy
aws application-autoscaling put-scaling-policy \
  --service-namespace ecs \
  --resource-id service/mcp-cluster/mcp-server-service \
  --scalable-dimension ecs:service:DesiredCount \
  --policy-name mcp-cpu-scaling-policy \
  --policy-type TargetTrackingScaling \
  --target-tracking-scaling-policy-configuration '{
    "TargetValue": 70.0,
    "PredefinedMetricSpecification": {
      "PredefinedMetricType": "ECSServiceAverageCPUUtilization"
    },
    "ScaleInCooldown": 300,
    "ScaleOutCooldown": 60
  }'
```

## Best Practices

### 1. Implement Proper Health Checks

Health checks are critical for ECS to determine container health and trigger replacements:

```javascript
// Example health check endpoint for Node.js MCP server
app.get('/health', async (req, res) => {
  try {
    // Check database connectivity
    await db.ping();

    // Check external API availability
    await checkExternalServices();

    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      error: error.message
    });
  }
});
```

### 2. Use Secrets Manager for Sensitive Data

Never hardcode credentials in Docker images or task definitions:

```bash
# Store API keys in Secrets Manager
aws secretsmanager create-secret \
  --name mcp-server/api-keys \
  --secret-string '{"openai":"sk-xxx","database":"postgres://user:pass@host"}'

# Reference in task definition using valueFrom
"secrets": [
  {
    "name": "OPENAI_API_KEY",
    "valueFrom": "arn:aws:secretsmanager:region:account:secret:mcp-server/api-keys:openai::"
  }
]
```

### 3. Optimize Container Images

Smaller images mean faster deployments and lower costs:
- Use multi-stage builds to exclude build dependencies
- Leverage Alpine Linux base images (typically 5-10x smaller)
- Use `.dockerignore` to exclude unnecessary files
- Scan images for vulnerabilities using ECR image scanning
- Implement layer caching strategies in CI/CD pipelines

### 4. Configure Proper Logging and Monitoring

Set up comprehensive observability:

```bash
# Create CloudWatch Log Group
aws logs create-log-group --log-group-name /ecs/mcp-server

# Set retention policy
aws logs put-retention-policy \
  --log-group-name /ecs/mcp-server \
  --retention-in-days 30

# Create CloudWatch alarms
aws cloudwatch put-metric-alarm \
  --alarm-name mcp-server-high-cpu \
  --alarm-description "Alert when MCP server CPU exceeds 80%" \
  --metric-name CPUUtilization \
  --namespace AWS/ECS \
  --statistic Average \
  --period 300 \
  --threshold 80 \
  --comparison-operator GreaterThanThreshold \
  --evaluation-periods 2
```

### 5. Implement Circuit Breakers

ECS deployment circuit breakers automatically roll back failed deployments:

```bash
aws ecs update-service \
  --cluster mcp-cluster \
  --service mcp-server-service \
  --deployment-configuration '{
    "deploymentCircuitBreaker": {
      "enable": true,
      "rollback": true
    },
    "maximumPercent": 200,
    "minimumHealthyPercent": 100
  }'
```

## Common Pitfalls

### 1. Insufficient Task Resources

**Problem:** MCP servers crash or perform poorly due to inadequate CPU/memory allocation.

**Why it's problematic:** ECS will continuously restart unhealthy tasks, creating a cycle of failures and impacting service availability.

**Solution:** Load test your MCP server to determine appropriate resource requirements:

```bash
# Monitor container resource usage
aws ecs describe-tasks \
  --cluster mcp-cluster \
  --tasks <task-id> \
  --include TAGS

# Adjust task definition CPU/memory based on observed usage
# Start with 256 CPU (0.25 vCPU) and 512 MB, scale up as needed
```

### 2. Missing IAM Task Role Permissions

**Problem:** MCP servers can't access AWS services (S3, DynamoDB, Bedrock) due to missing IAM permissions.

**Why it's problematic:** Operations fail silently or with cryptic permission errors, making debugging difficult.

**Solution:** Create a dedicated IAM task role with least-privilege permissions:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject"
      ],
      "Resource": "arn:aws:s3:::mcp-data-bucket/*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "bedrock:InvokeModel"
      ],
      "Resource": "*"
    }
  ]
}
```

Always test IAM policies in a development environment before production deployment.

### 3. Not Planning for Network Configuration

**Problem:** MCP servers can't communicate with other AWS services or receive traffic from load balancers.

**Why it's problematic:** Services appear healthy but fail to process requests, leading to timeout errors.

**Solution:** Configure security groups and network ACLs correctly:

```bash
# Allow ALB to reach ECS tasks
aws ec2 authorize-security-group-ingress \
  --group-id sg-ecs-tasks \
  --protocol tcp \
  --port 3000 \
  --source-group sg-alb

# Allow ECS tasks to reach internet (for API calls)
# Ensure tasks are in private subnets with NAT Gateway
# OR use public subnets with assignPublicIp=ENABLED
```

## Conclusion

Deploying MCP servers on AWS ECS provides a scalable, reliable foundation for extending Claude Code capabilities in production environments. By containerizing your servers, leveraging Fargate for serverless compute, and implementing auto-scaling and health checks, you can ensure your AI infrastructure remains responsive and cost-effective.

**Key Takeaways:**
- Containerization enables consistent MCP server deployments across environments
- ECS Fargate eliminates infrastructure management overhead for most workloads
- Proper health checks and monitoring ensure high availability
- Auto-scaling policies adapt to demand without manual intervention
- Security best practices protect sensitive credentials and data

**Next Steps:**
- Implement blue/green deployments for zero-downtime updates
- Integrate with AWS App Mesh for advanced service mesh capabilities
- Set up CI/CD pipelines with CodePipeline for automated deployments
- Explore ECS Anywhere for hybrid cloud MCP server deployments
- Monitor costs with AWS Cost Explorer and implement FinOps practices

Ready to take your infrastructure further? Try deploying multiple MCP servers behind a single load balancer and implement request routing based on MCP tool capabilities.

## Further Reading

- [AWS ECS Developer Guide](https://docs.aws.amazon.com/ecs/)
- [Amazon ECR User Guide](https://docs.aws.amazon.com/ecr/)
- [ECS Task Networking Best Practices](https://docs.aws.amazon.com/AmazonECS/latest/bestpracticesguide/networking.html)
- [Model Context Protocol Specification](https://modelcontextprotocol.io/)
- Building High-Availability MCP Architectures (coming soon)
- Cost Optimization Strategies for ECS Workloads (coming soon)
